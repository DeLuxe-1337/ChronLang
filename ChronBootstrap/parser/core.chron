include parser.state

Parser.Statement.Include :: (state) {
    if Parser.State.Match(Parser.State.Get(state), "IDENTIFIER", "include") and Parser.State.Match(Parser.State.Peek(state, 1), "IDENTIFIER", nil) {
        path = Parser.State.Next(state)["value"]
        PrintLn("Include path: " + path)

        Parser.State.IncreaseIndex(state)

        PrintLn("Include stmt valid")
    }
    return nil
}

Parser.Statement.Function :: (state) {
    if Parser.State.Match(Parser.State.Get(state), "IDENTIFIER", nil) and Parser.State.Match(Parser.State.Peek(state, 1), "CONSTANT", nil) {
        name = Parser.State.GetAndIncrease(state)["value"]

        PrintLn("Function: " + name)
        Parser.State.IncreaseIndex(state)

        block = Parser.Statement.Block(state)
        if block != nil {
            return IR.CreateFunction(Clone(name), Clone(block), nil)
        }

        PrintLn("Function stmt valid")
    }
    return nil
}

Parser.Statement.Invoke :: (state) {
    if Parser.State.Match(Parser.State.Get(state), "IDENTIFIER", nil) and Parser.State.Match(Parser.State.Peek(state, 1), "LPAREN", nil) {
        name = Parser.State.GetAndIncrease(state)["value"]

        Parser.State.IncreaseIndex(state)

        parameters = <>
        parameter_index = 0
        while Parser.State.Get(state)["type"] != "RPAREN" {
            parameters[parameter_index] = Parser.Expression(state)
            parameter_index += 1
        }
        
        Parser.State.IncreaseIndex(state)

        PrintLn("Invoke stmt valid")

        PrintLn(parameters)

        return IR.CreateInvoke(IR.CreateEnvironmentAccessor(name), Clone(parameters))
    }
    return nil
}

Parser.Statement.Block :: (state) {
    if Parser.State.Match(Parser.State.Get(state), "LBRACKET", nil) {
        Parser.State.IncreaseIndex(state)
        block = IR.CreateBlock()
        while Parser.State.Get(state)["type"] != "RBRACKET" {
            IR.Block.Append(block, Parser.Statement(state))
        }
        Parser.State.IncreaseIndex(state)
        PrintLn("Block stmt valid")
        return Clone(block)
    }
    return nil
}

Parser.Statement :: (state) {
    stmt = Parser.Statement.Include(state)
    if stmt != nil { return stmt }

    stmt = Parser.Statement.Function(state)
    if stmt != nil { return stmt }

    stmt = Parser.Statement.Invoke(state)
    if stmt != nil { return stmt }

    stmt = Parser.Statement.Block(state)
    if stmt != nil { return stmt }

    return nil
}

Parser.Expression.String :: (state) {
    if Parser.State.Match(Parser.State.Get(state), "STRING", nil) {
        return IR.CreateString(Parser.State.GetAndIncrease(state)["value"])
    }

    return nil
}

Parser.Expression :: (state) {
    expr = Parser.Expression.String(state)
    if expr != nil { return expr } 

    return nil
}