include lexer.token
include lexer.state

Lexer.SymbolMap = <
    "("="LPAREN", ")"="RPAREN", 
    "{"="LBRACKET", "}"="RBRACKET", 
    "["="LBRACE", "]"="RBRACE", 
    "true"="TRUE", "false"="FALSE",
    ","="COMMA", 
    "!"="EXCLAMATION", 
    "="="EQUAL", 
    ">"="GREATER", 
    "<"="LESS", 
    "?"="QUESTION", 
    "+"="PLUS", 
    "-"="MINUS", 
    "/"="FSLASH", 
    "*"="STAR", 
    "%"="PERCENT", 
    "or"="OR",
    "and"="A",
    "nil"="NIL",
    "defer"="DEFER",
    "release"="RELEASE",
    "return"="RETURN",
    "include"="INCLUDE"
>

Lexer.GetToken :: (state) {
    while ((String.IsWhitespace(Lexer.State.Get(state))) or (Lexer.State.Get(state) == "\n")) and (Lexer.State.EOF(state) == false) {
        if Lexer.State.Get(state) == "\n" {
            state["currentLine"] += 1
        }
        Lexer.State.IncreaseIndex(state)
    }

    if ((Lexer.State.Get(state) == "/") and (Lexer.State.Peek(state, 1) == "/")) and (Lexer.State.EOF(state) == false) {
        while (Lexer.State.Get(state) != "\n") and (Lexer.State.EOF(state) == false) {
            Lexer.State.IncreaseIndex(state)
        }

        Lexer.State.IncreaseIndex(state)
        state["currentLine"] += 1
    }

    if String.IsAlpha(Lexer.State.Get(state)) and (Lexer.State.EOF(state) == false) {
        identifier = ""
        while (String.IsAlphaNumeric(Lexer.State.Get(state)) or (Lexer.State.Get(state) == ".") or (Lexer.State.Get(state) == "_")) and (Lexer.State.EOF(state) == false) {
            identifier += Lexer.State.Get(state)
            Lexer.State.IncreaseIndex(state)
        }

        foreach symbol, type in Table.Iter(Lexer.SymbolMap) {
            if identifier == symbol {
                return Lexer.Token.Create(symbol, type, state["currentLine"])
            }
        }

        return Lexer.Token.Create(identifier, "IDENTIFIER", state["currentLine"])
    }

    if String.IsNumeric(Lexer.State.Get(state)) and (Lexer.State.EOF(state) == false) {
        number = ""
        while (String.IsNumeric(Lexer.State.Get(state))) and (Lexer.State.EOF(state) == false) {
            number += Lexer.State.Get(state)
            Lexer.State.IncreaseIndex(state)
        }
        return Lexer.Token.Create(number, "NUMBER", state["currentLine"])
    }

    if Lexer.State.Get(state) == "\"" and (Lexer.State.EOF(state) == false) {
        string = ""

        Lexer.State.IncreaseIndex(state)

        while Lexer.State.Get(state) != "\"" and (Lexer.State.EOF(state) == false) {
            string += Lexer.State.Get(state)
            Lexer.State.IncreaseIndex(state)
        }
        
        Lexer.State.IncreaseIndex(state)
        
        return Lexer.Token.Create(string, "STRING", state["currentLine"])
    }

    if Lexer.State.Get(state) == ":" and (Lexer.State.EOF(state) == false) {
        Lexer.State.IncreaseIndex(state)
        if(Lexer.State.Get(state) == ":") {
            Lexer.State.IncreaseIndex(state)
            return Lexer.Token.Create("::", "CONSTANT", state["currentLine"])
        }
        else {
            return Lexer.Token.Create(":", "COLON", state["currentLine"])
        }
    }

    foreach symbol, type in Table.Iter(Lexer.SymbolMap) {
        if Lexer.State.Get(state) == symbol {
            Lexer.State.IncreaseIndex(state)
            return Lexer.Token.Create(symbol, type, state["currentLine"])
        }
    }

    if (Lexer.State.EOF(state) == false) {
        PrintLn("Unmatched character (" + Lexer.State.Get(state) + ") skipping...")
        Lexer.State.IncreaseIndex(state)
    }

    return nil
}

Lexer.GetAllTokens :: (state) {
    tokens = <>

    while Lexer.State.EOF(state) == false {
        result = Lexer.GetToken(state)
        if result != nil {
            tokens[Table.SizeOf(tokens)] = result
        }
    }

    return Clone(tokens)
}